# Faq.

## Что это?
Пример того как необходимо группировать запросы в своем проекте.
В данном случае предполагается что в проекте используется webpack.
И да это не золотая пилюля, но является архитектурным решением, которое необходимо сконфигурировать под себя.

## Как получать обновления
Обновление Request Manager - это трудоемкий процесс (стоит быть осторожными).
Я рекомендую привязываться к конкретной последней версии.
В большинстве случаев, вы затачиваете все под себя и под свой backend.
В финальном варианте, у вас получается своя SDK, местами со своими костылями...
Но я постарался его упростить максимально, вынося информацию по обновлению в отдельные гайды.

## Зачем мне лишний ...
Увы большая часть проблем возникает при разрастании проекта, а не в начале.
В начале проекта у вас 5 запросов и поменять что-либо не проблема (даже все переписать).
Затем у вас запросов так 15-20 (что-то поправить муторно, но возможно).
В конце у вас уже 40+ запросов и пути назад уже нет...

В данном случае, лучше решить проблемы с запросами на начальном этапе и потом забыть о них на очень долго...

Обычно, что бы подружить фронт и бек уходит до 2 дней (иногда больше).
В данном случае, со временем это сведется к 2-4 часам.

## "Я могу лучше"
Без проблем). Я не обижусь. 
Но все же стоит знать, что данное решение не возникло за два дня и за ним стоит более 3 лет проб и ошибок.
Понятное дело, что я не писал 3 года только это и ничего больше.
Это были разные проекты, которые обращались куда-либо.
В итоге получилось, то что получилось.

## Возможности

- кэшировать запросы; 
- менять axios на fetch и наоборот (требует писанины);
- делать пред обработку данных;
- отдавать фейковые данные;
- выводить сообщения с ошибкой
- вешать лоадер

Многое из этого требует интеграции с вашей системой. 
По этому финальный функционал определять вам.

## Что мы получаем в итоге

В итоге мы получаем возможность централизованно обрабатывать все запросы.
Мы не заморачиваемся с преобразованием данных в коде, а лишь работаем с чистыми данными.
Лучше 1 раз увидеть, чем 100 раз услышать
```js
// так же можно использовать async/await - кому это необходимо
RequestManager.Auth.authorization({login: 'admin', password: 'pass'})
  .then(
    (result) => {
      alert('авторизация прошла успешно! да, да именно успешно и это не упрощение!!!');
      // + другие действия
    },
    (error) => {
      alert('не удалось авторизоваться');
       // + другие действия
    }
  )
```

## Обработка ошибок сервера.
В своих проектах, я использую глобальную обработку ошибок сервера, через RequestManager.
Вследствие этого, мне в 90% запросов не нужен блок "(error) => {}".
Когда мне не нужно выводить сообщение при ошибке, я просто передаю доп. параметр.

## Осторожнее с Promise.catch()
Стоит осторожными с блоком catch.
После выполнения блока catch, вы получите аналог успешного "Promise".
Если такое поведение не требуется, то стоит вернуть "Promise.reject(error);" 

## Осторожнее с async/await
И пример с async/await
```js
try {
  // ... code
  result = await RequestManager.Auth.authorization({login: 'admin', password: 'pass'})  
} catch (e) {
   // очень часто люди забывают, что запрос не прошел
   // а саму ошибку может вызвать не только запрос
  return;
}
// и продолжают писать, как не в чем не бывало
alert('авторизация прошла успешно!');
```

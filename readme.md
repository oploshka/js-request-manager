# Менеджер запросов к API.

## Что это
Пример того как необходимо группировать запросы в своем проекте. В данном случае предполагается что в проекте используется webpack. И да это не золотая пилюля, но является архитектурным решением, которое необходимо доработать под себя.

## Как получать обновления
Никак (или очень долго и нудно смотреть что поменялось). 
В большинстве случаев, вы затачиваете все под себя и под свой backend.
В финальном варианте, у вас получается своя SDK, местами со своими костылями... 
В этом нет чего-то плохого.
В дальнейших версиях эта проблема будет так же затронута и процесс обновления станет менее проблематичным.

## Зачем мне лишний ...
Увы большая часть проблем возникает при разрастании проекта, а не в начале.
В начале проекта у вас 5 запросов и поменять что-либо не проблема (даже все переписать), затем у вас запросов так 15-20 (что-то поправить муторно, но возможно).
В конце у вас уже 40+ запросов и пути назад уже нет...

В данном случае, лучше решить проблемы с запросами на начальном этапе и потом забыть о них на очень долго...

Обычно, что бы подружить фронт и бек уходит до 2 дней (иногда больше). В данном случае, со временем это сведется к 2-4 часам.

## "Я могу лучше"
Без проблем). Я не обижусь. 
Но все же стоит знать, что данное решение не возникло за два дня и за ним стоит более 3 лет проб и ошибок.
Понятное дело, что я не писал 3 года только это и ничего больше.
Это были разные проекты, которые обращались куда-либо.
В итоге получилось, то что получилось.

## Возможности

- кэшировать запросы; 
- менять axios на fetch и наоборот (требует писанины);
- делать пред обработку данных;
- отдавать фейковые данные;
- выводить сообщения с ошибкой
- вешать лоадер

Многое из этого требует интеграции с вашей системой. 
По этому финальный функционал определять вам.

## Установка

1) прописать алиас в конфиге webpack
    ```
    @requestManager' = '.../RequestManager/src',
    ```


2) src/Configuration/HostSchema.js - описываем имя сокращения для хостов. 
   Делаем это для того, чтобы иметь возможность версионировать или слать запросы на разные url. 
   Пример:
    ```js
    const hostSchema = {
      http : 'http://',
      https: 'https://',
      api  : 'https://backend.domain/api/',
    };
    
    export default hostSchema;
    ```


3) в папке src/Request по образу и подобию описываем, что и куда нам нужно отправлять


4) src/Configuration/RequestSchema.js - описываем структуру


5) идем в файл src/SendRequest.js и долго и нудно понимаем, как все это отправляется...
   (это требует упрощения, но пока что это в TODO).
   Этот файл затачивается под ваш бек, вы выбираете через что отправлять (axios/fetch/...)

## Что мы получаем в итоге

В итоге мы получаем возможность централизованно обрабатывать все запросы.
Мы не заморачиваемся с преобразованием данных в коде, а лишь работаем с чистыми данными.
Лучше 1 раз увидеть, чем 100 раз услышать
```js
// так же можно использовать async/await - кому это необходимо
RequestManager.Auth.authorization({login: 'admin', password: 'pass'})
  .then(
    (result) => {
      alert('авторизация прошла успешно! да, да именно успешно и это не упрощение!!!');
      // + другие действия
    },
    (error) => {
      alert('не удалось авторизоваться');
       // + другие действия
    }
  )
```

Хотелось бы так же добавить, что обработку ошибок с сервера,
в моих проектах выполняет RequestManager и в 99% мне не нужен блок "(error) => {}".

Стоит так же отметить, что стоит быть осторожными с блоком catch.
После выполнения блока catch, вы получите аналог успешного промиса.
Если такое поведение не требуется, то стоит вернуть "Promise.reject(error);" 

И пример с async/await
```js
try {
  // кусок кода
  result = await RequestManager.Auth.authorization({login: 'admin', password: 'pass'})  
} catch (e) {
   // очень часто люди забывают, что запрос не прошел
   // а саму ошибку может вызвать не только запрос
  return;
}
// и продолжают писать, как не в чем не бывало
alert('авторизация прошла успешно!');
```
